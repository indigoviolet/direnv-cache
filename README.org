:DOC-CONFIG:
#+startup: fold
#+title: Direnv caching
#+author: Venky Iyer
#+email: indigoviolet@gmail.com
:END:

This is an implementation of caching for [[https://direnv.net/][direnv]].

~direnv-cache~ caches the environment into a ~.env~ file using ~direnv~ (and then
loads the ~.env~ using direnv itself).

It supports rebuilds when [[*Cache validity][the cache becomes invalid]].

* Motivation

I use direnv for setting up [[https://python-poetry.org/][Poetry]] ([[https://github.com/direnv/direnv/wiki/Python#poetry][layout_poetry]]) or conda, and in these
scenarios, the environment created via direnv doesn't change all that often, and
is amenable to caching.

I also use direnv in Emacs ([[https://github.com/purcell/envrc][envrc]]), and having fast loads would make my editor
start up faster.

I could use a ~.env~ directly but it's convenient to create the environment
programmatically with direnv.

* Installation

The accompanying file [[cache.sh][cache.sh]] should be dropped into direnv's library: either
appended to ~~/.config/direnv/direnvrc~ or dropped into ~~/.config/direnv/lib/~

#+begin_src bash

#+end_src

* Usage

Add the ~use_cache~ function to the top of your ~.envrc~:


#+begin_example
$> cat .envrc

#+end_example



* Cache validity

1. The cache file ~.env~ exists
2. It is newer than any "dependencies" - which are assumed to be all the files
   that direnv is watching (see ~direnv help show_private~ or ~watch_file~ in the
   [[https://direnv.net/man/direnv-stdlib.1.html][stdlib]])
3. A rebuild can be forced by setting (via ~export~) ~DIRENV_CACHE_REBUILD~

* Environment variables

- ~DIRENV_CACHE_IGNORE~ ::
- ~DIRENV_CACHE_REBUILD~ ::
- ~DIRENV_CACHE_DEBUG~ ::

* Should this be built into direnv?

* Implementation Notes
** behavior of DIRENV_WATCHES

- when we first hit .envrc code, DIRENV_WATCHES is already set in the environment and contains the .envrc and allow file
- if you add a watch manually, it will append to DIRENV_WATCHES
- but ~direnv export json~ will only show the watches added in the envrc (by default only the .envrc and allow file)
- ~dotenv_if_exists~ will ~watch_file~ .env (appending to DIRENV_WATCHES)


*** viewing dumps

#+begin_src bash
direnv show_dump $DIRENV_WATCHES
#+end_src

#+begin_src bash
echo $DIRENV_WATCHES | python -c "import sys; import zlib; import base64; print(zlib.decompress(base64.urlsafe_b64decode(sys.stdin.read())).decode('utf-8'))" | jq '.'
#+end_src


** implementation notes

- We build the cache by running ~direnv export json~ in a subshell with a (mostly)
  clean environment (while ignoring caching), and then formatting the JSON into
  dotenv with ~jq~. This is then dumped into .env.


*** Watching .env

.env will get watched when we use ~dotenv_if_exists~, which modifies
DIRENV_WATCHES, but then immediately the DIRENV_WATCHES from the cache will
overwrite this, so that .env will not be watched.

Do we want to watch the cache file? I don't think so: users shouldn't be
modifying it directly; if deleted, it will get recreated the next time ~direnv~
tries to load something.

Attempting to get the cache file into DIRENV_WATCHES turns out to be difficult -
you need to first set the .env's DIRENV_WATCHES into the environment (to capture
any watches set in .envrc), and then ~watch_file .env~, and then append that new
DIRENV_WATCHES into .env (overriding the previous export).

TODO: Can we do it like below, in one step?

#+begin_example
{ direnv watch json .env | jq -r '"export DIRENV_WATCHES=\(.DIRENV_WATCHES|@sh)"' >> .env; eval $(direnv watch zsh .env); }
#+end_example









* Code
:PROPERTIES:
:header-args:bash: :comments both :tangle cache.sh
:END:

** Shellcheck

#+begin_src bash :comments no
# shellcheck disable=SC2155
#+end_src

** Main entry point
#+begin_src bash
use_cache() {
    # show_dump $DIRENV_WATCHES

    [[ -v DIRENV_CACHE_IGNORE ]] && {
        _debug "Ignoring cache, DIRENV_CACHE_IGNORE is set"
        return
    }
    [[ ${DIRENV_CACHE_DEBUG:-0} -gt 1 ]] && {
        set_x
        set -uo pipefail
    }
    echo "$DIRENV_WATCHES"
    local cache_file="${1:-$(pwd)/.env}"
    shift
    if ! cache_is_valid "$cache_file" "$@"; then
        build_cache "$cache_file" || {
            _debug "Cache build failed"
            exit $?
        }
    fi

    _debug "Loading from cache ${cache_file}"
    dotenv_if_exists "$cache_file"
    exit 0
}
#+end_src

** Check cache validity

#+begin_src bash
cache_is_valid() {
    # Checks cache validity, and returns 0 for valid cache, nonzero for invalid cache.
    #
    # * Parameters
    #
    # - cache_file
    # - dependency_files :: an optional list of files that the cache file must be newer than
    #
    # * Conditions for valid cache
    #
    # 1. DIRENV_CACHE_REBUILD is not set (set this to force rebuilds)
    # 2. cache file exists
    # 3. cache file is newer than dependency files

    [[ ! -v DIRENV_CACHE_REBUILD ]] || {
        _debug "Rebuilding cache, DIRENV_CACHE_REBUILD is set"
        return
    }

    local cache_file=${1:?"Cache file required"}
    [[ -f "$cache_file" ]] || {
        _debug "Cache invalid: $cache_file missing"
        return
    }
    is_newest "$@" || {
        _debug "Cache invalid: not newest"
        return
    }
    _debug "Cache is valid"
    true
}

#+end_src

** Build cache

#+begin_src bash
build_cache() {
    # Builds the cache by calling ~direnv export~ in a clean login shell (which
    # is the "base" environment to diff against).
    #
    # * Parameters:
    #
    # - cache_file :: the dotenv file to cache into
    #
    # * Requirements:
    #
    # - jq :: to parse json export into dotenv format

    local cache_file=${1:?"Cache file required"}

    # We use the login shell to capture any user config in the baseline
    local shell=$(basename "$SHELL")
    local working_dir=$(dirname "$cache_file")
    local direnv=$(which direnv)

    if [[ -v DIRENV_CACHE_DEBUG ]]; then
        local stderr_file=$(mktemp)
    else
        local stderr_file=/dev/null
    fi

    # We first add the cache file to the watch list, and then export -- this
    # makes the cache file be included in DIRENV_WATCHES in the cached env.
    #
    # we use json/jq because the bash export uses $'' c-strings which are not
    # easy to get rid of with sed
    local direnv_export_cmd="${direnv} export json"

    # DIRENV_LOG_FORMAT='' will turn off direnv logging
    # DIRENV_CACHE_IGNORE=1 so that we can build the cache without using it
    local cache_contents=$(env -i \
        --chdir "$working_dir" \
        HOME="$HOME" \
        TERM="$TERM" \
        DIRENV_CACHE_IGNORE=1 \
        DIRENV_LOG_FORMAT="" \
        "$shell" -ilc "$direnv_export_cmd" 2>"$stderr_file" |
                               jq -r 'to_entries | map("export \(.key)=\(.value|@sh)")[]')

    local status=$?
    if [[ -v DIRENV_CACHE_DEBUG ]]; then
        local stderr_content=$(<"$stderr_file") && rm "$stderr_file"
    else
        local stderr_content=""
    fi
    if [[ $status -eq 0 ]]; then
        echo "$cache_contents" >"$cache_file"
        _debug "Built ${shell} cache for ${working_dir}: ${cache_file} contents: <${cache_contents}> stderr: <$stderr_content>"
        return
    else
        _debug "Cache build failed: $stderr_content"
        return $status
    fi
}
#+end_src

** Dependency files

each time direnv enters the directory it has to load from .envrc

but on each prompt, it only reloads if the watch list indicates that the env is stale


#+begin_src bash
direnv show_dump $DIRENV_WATCHES | jq '.[].Path'
#+end_src


# get_watch_files() {

# }

** Is cache file the newest?

#+begin_src bash
is_newest() {
    # Checks if cache_file is newer than all dependency files. Returns 0 if yes, nonzero if not.
    #
    # * Parameters
    #
    # - cache_file
    # - dependency files
    [[ $# -eq 1 ]] && {
        _debug "No dependencies"
        return
    }

    local cache_file=${1:?"Cache file required"}
    shift
    for f in "$@"; do
        [[ "$cache_file" -nt "$f" ]] || {
            _debug "Cache invalid: $cache_file is older than $f"
            return
        }
    done

    true
}

#+end_src

** Debug printing
#+begin_src bash
_debug() {
    # Return status of this function is always the previous status.
    #
    # Prints $1 if DIRENV_CACHE_DEBUG is set. (Note that you probably have to
    # ~export~ it, not just set it, since all this code runs in a subshell)

    {
        local status=$?
        [[ -o xtrace ]] && {
            shopt -uo xtrace
            local xtrace_was_on=1
        }
    } 2>/dev/null

    local msg=${1:?"Message required"}
    [[ -v DIRENV_CACHE_DEBUG ]] && echo "$msg (status: $status)" >&2

    {
        [[ ${xtrace_was_on:-0} -eq 1 ]] && shopt -so xtrace
        return $status
    } 2>/dev/null
}
#+end_src

** Emacs local variables

#+begin_src bash :comments no
# Local Variables:
# sh-shell: bash
# End:
#+end_src
